# 民泊向けBYODチェックインシステム

## 概要
本プロジェクトは、民泊施設におけるゲストのチェックイン・アウト、アメニティのリクエスト、宿泊税の支払い、観光案内などを、ゲスト自身のスマートフォンから行えるようにするBYOD（Bring Your Own Device）型システムを構築することを目的としています。

## 目的
*   ゲストの利便性向上とスムーズなチェックイン・アウト体験の提供。
*   アメニティ追加依頼の効率化。
*   宿泊税の現地支払い機能の導入。
*   周辺観光情報の充実と提供方法の改善。
*   施設側でのハードウェア（タブレットなど）の管理コスト削減と運用効率化。

## 主な機能（予定）

### 1. オンラインチェックイン・アウト機能
*   **チェックイン:**
    *   到着前のゲスト情報（氏名、国籍、連絡先など）登録。
    *   本人確認書類（パスポートなど）の画像アップロード機能。
    *   滞在中の利用規約への同意。
    *   スマートロックの開錠コードや、物理キーの受け取り方法の表示。
*   **チェックアウト:**
    *   チェックアウト確認ボタン。
    *   忘れ物確認やゴミ出しに関する案内。
    *   滞在フィードバックの収集。

### 2. アメニティリクエスト機能
*   利用可能なアメニティ（追加タオル、歯ブラシ、追加寝具など）のリスト表示。
*   必要なアメニティと数量を選択してリクエストを送信。
*   リクエスト状況（受付済み、配達中、完了）の確認。
*   備考欄で特別な要望を追記可能。

### 3. 宿泊税オンライン決済機能
*   ゲストの予約情報に基づいた宿泊税額の表示。
*   クレジットカード、デビットカード、その他の電子決済（例: PayPay, LINE Payなど検討）による決済機能。
*   決済完了後の領収書（PDFなど）の発行・ダウンロード。
*   多言語対応による税金の説明。

### 4. 観光・交通情報案内機能
*   **周辺情報:**
    *   観光スポット、飲食店、ショッピング施設、コンビニなどのカテゴリ別リスト表示。
    *   各スポットの詳細情報（営業時間、定休日、住所、電話番号、ウェブサイト、写真など）。
    *   Googleマップなど外部地図サービスへの連携リンク。
*   **交通情報:**
    *   最寄りの駅、バス停、タクシー乗り場などの案内。
    *   空港や主要駅へのアクセス方法。
    *   時刻表や経路検索サービスへの連携。
*   **多言語対応:** 主要な観光情報の多言語表示。

### 5. 施設からのお知らせ・緊急連絡機能
*   施設側からゲスト全体、または特定のゲストグループへのお知らせ（例: 清掃時間、イベント情報など）を通知。
*   緊急時（災害、設備トラブルなど）の連絡先、避難経路、対応手順などの表示。
*   よくある質問（FAQ）へのリンク。

## 技術スタック（提案）

### AIコンシェルジュ機能
*   **必須機能**としてAIコンシェルジュ機能を実装します。
*   **役割:** AIコンシェルジュは、各機能（チェックイン、アメニティリクエスト等）を内包するのではなく、会話を通じてゲストを適切な機能へ案内する「総合的なゲートウェイ（入口）」として機能します。これにより、統一されたインターフェースでシームレスな体験を提供します。
*   **フロントエンド:** React (ユーザーインターフェース、チャット画面など)
*   **バックエンド:** Node.js (APIサーバー、Gemini API連携、データ管理など)
*   **AIモデル:** Gemini API (パーソナルコンシェルジュの頭脳部分)

### 今後の開発方針
*   上記技術スタックを基盤としてWebアプリケーションを開発します。
*   まずはAIコンシェルジュ機能のMVP (Minimum Viable Product) 構築を目指し、その後他の機能を追加していく予定です。

## 機能設計とAPIエンドポイント

### 1. AIコンシェルジュの全体的な流れ (シーケンス)
1.  **フロントエンド:** ゲストがチャットUIにメッセージを入力し、送信ボタンを押す。
2.  **フロントエンド:** 現在の会話履歴と新しいメッセージをまとめて、バックエンドのAPI (`/api/concierge/chat`) にPOSTリクエストを送信する。
3.  **バックエンド:** リクエストを受け取り、会話履歴、ゲストの好み（もしあれば）、そして我々が事前に用意した観光スポットなどの**コンテキスト情報**を元に、Gemini API（AIモデル）への指示（プロンプト）を組み立てる。
4.  **バックエンド:** Gemini APIを呼び出し、AIからの返答を受け取る。
5.  **バックエンド:** AIの返答を整形し、必要に応じて地図表示やリンクなどの**構造化されたデータ**（ただの文章ではない、ボタンなどを表示するためのデータ）を付与して、フロントエンドにJSON形式で返す。
6.  **フロントエンド:** バックエンドからの返答を受け取り、チャットUIにAIのメッセージを表示する。もし構造化されたデータがあれば、それもボタンやカードとして表示する。

### 2. APIエンドポイント

*   **エンドポイント:** `POST /api/concierge/chat`
*   **役割:** ゲストからのチャットメッセージを受け取り、AIの返答を返す。

**リクエストボディ (フロントエンド → バックエンド)**
```json
{
  "sessionId": "unique-session-id-for-each-guest",
  "message": "近くでおすすめのカフェはありますか？",
  "conversationHistory": [
    { "role": "user", "content": "こんにちは" },
    { "role": "assistant", "content": "こんにちは！何かお探しですか？" }
  ]
}
```

**レスポンスボディ (バックエンド → フロントエンド)**
```json
{
  "reply": "はい、承知いたしました。近くでおすすめのカフェを一件ご紹介しますね。",
  "suggestions": [
    {
      "type": "place_card",
      "data": {
        "name": "アバーテ喫茶",
        "imageUrl": "https://images.example.com/abarth-cafe.jpg",
        "description": "レトロな雰囲気でコーヒーが美味しい人気のカフェです。Wi-Fiも完備しています。",
        "address": "東京都千代田区丸の内1-2-3",
        "rating": 4.5,
        "reviewCount": 128,
        "map": {
          "latitude": 35.681236,
          "longitude": 139.767125
        },
        "websiteUrl": "http://abarth-cafe.example.com"
      }
    },
    {
      "type": "quick_reply",
      "label": "ありがとう！"
    },
    {
      "type": "quick_reply",
      "label": "他の候補はありますか？"
    }
  ]
}
```
## 開発手順 (MVP)

#### ステップ1: 【バックエンド】モックAPIの構築
*   **内容:** `server/index.js` に、設計した `POST /api/concierge/chat` エンドポイントを作成します。この時点ではAIは呼び出さず、あらかじめ用意した固定のJSONデータ（モックデータ）を返すようにします。
*   **目的:** フロントエンド側が、バックエンドのAI実装を待たずに開発・テストを進められるようにするため。

#### ステップ2: 【フロントエンド】チャットUIの作成
*   **内容:** `client/src` に、チャットの画面を構築します。具体的には以下の要素を作成します。
    1.  会話の履歴を表示するエリア
    2.  ユーザーがメッセージを入力するテキストボックス
    3.  送信ボタン
*   **目的:** ゲストが操作するインターフェースの骨格を作るため。

#### ステップ3: 【フロントエンド】APIの連携
*   **内容:** ステップ2で作成したUIから、ステップ1で作成したバックエンドのモックAPIを呼び出す処理を実装します。送信ボタンが押されたらAPIにリクエストを送り、返ってきたモックデータを画面に表示させます。
*   **目的:** フロントエンドとバックエンド間の通信が正しく行えることを確認するため。

#### ステップ4: 【バックエンド】Gemini APIとの連携
*   **内容:** モックAPIを、実際にGemini APIを呼び出す処理に置き換えます。
    1.  Gemini APIを利用するためのライブラリをインストールします。
    2.  APIキーを安全に管理する仕組み（`.env`ファイル）を導入します。
    3.  設計書通りに、会話履歴やコンテキスト情報を組み立ててAIへの指示（プロンプト）を作成し、Gemini APIを呼び出します。
    4.  AIからの返答を整形し、フロントエンドに返します。
*   **目的:** コンシェルジュ機能に知能を持たせ、実際の会話を可能にするため。

#### ステップ5: 【バックエンド】コンテキスト情報（推薦リスト）の実装
*   **内容:** AIに渡すコンテキスト情報として、施設が推薦する観光スポットや飲食店のリストをJSONファイル（例: `recommendations.json`）として作成します。バックエンドは起動時にこのファイルを読み込み、AIへのプロンプトに含めるようにします。
*   **目的:** AIの回答の質と信頼性を高め、施設独自の推薦を行えるようにするため。

#### ステップ6: 総合テストと調整
*   **内容:** フロントエンドからバックエンド、AIまでの一連の流れを実際に操作してテストします。UIの微調整や、AIへの指示の改善、エラー処理などを行います。
*   **目的:** MVPとしての最低限の品質を確保するため。